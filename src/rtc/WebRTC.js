/**
 * Copyright 2017 PhenixP2P Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
define([
    'phenix-web-lodash-light',
    './DetectBrowser',
    'webrtc-adapter'
], function (_, DetectBrowser, webRtcAdapter) { // eslint-disable-line no-unused-vars
    'use strict';

    var log = function () {
        console.log.apply(console, arguments);
    };

    var browser = new DetectBrowser(navigator.userAgent).detect();
    var RTCPeerConnection = window.RTCPeerConnection;
    var RTCSessionDescription = window.RTCSessionDescription;
    var RTCIceCandidate = window.RTCIceCandidate;
    var getSources = null;
    var getUserMedia = null;
    var getStats = null;
    var attachMediaStream = null;
    var reattachMediaStream = null;
    var webrtcSupported = false;

    function shimRTC() {
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
            getSources = navigatorMediaDevicesEnumerateDevicesWrapper;
        }

        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            getUserMedia = navigatorGetUserMedia;
        }

        if (!window.RTCPeerConnection) {
            return log('[%s] browser version [%s] does not appear to be WebRTC-capable', browser.browser, browser.version);
        }

        switch (browser.browser) {
        case 'Firefox':
            log('Firefox detected', browser);

            // Attach a media stream to an element.
            attachMediaStream = function (element, stream) {
                log('Attaching media stream');

                var muted = element.muted;

                element.mozSrcObject = stream;
                element.play();

                if (muted === true) {
                    // FF unmutes upon play()
                    element.muted = true;
                }

                return element;
            };

            reattachMediaStream = function (to, from) {
                log('Reattaching media stream');

                var muted = to.muted;

                to.mozSrcObject = from.mozSrcObject;
                to.play();

                if (muted === true) {
                    // FF unmutes upon play()
                    to.muted = true;
                }

                return to;
            };

            getStats = function getPeerConnectionStats(pc, track, successCallback, errorCallback) {
                pc.getStats(track, _.bind(handleGetStatsSuccess, this, pc, successCallback), errorCallback);
            };

            webrtcSupported = true;

            break;
        case 'Opera':
            log('Opera detected', browser);

            attachMediaStream = attachStreamToElement;
            reattachMediaStream = reattachStreamToElement;
            getStats = function getPeerConnectionStats(pc, track, successCallback, errorCallback) {
                pc.getStats(_.bind(handleGetStatsSuccess, this, pc, successCallback), track, errorCallback);
            };

            webrtcSupported = true;

            break;
        case 'Chrome':
            log('Webkit detected', browser);

            attachMediaStream = attachStreamToElement;
            reattachMediaStream = reattachStreamToElement;
            getStats = function getPeerConnectionStats(pc, track, successCallback, errorCallback) {
                pc.getStats(_.bind(handleGetStatsSuccess, this, pc, successCallback), track, errorCallback);
            };

            webrtcSupported = true;

            break;
        case 'Edge':
            log('Edge detected', browser);

            attachMediaStream = attachStreamToElement;
            reattachMediaStream = reattachStreamToElement;
            getStats = function getPeerConnectionStats(pc, track, successCallback, errorCallback) {
                pc.getStats(track, _.bind(handleGetStatsSuccess, this, pc, successCallback), errorCallback);
            };

            webrtcSupported = true;

            break;
        case 'Safari':
            log('Safari detected', browser);

            attachMediaStream = attachStreamToElement;
            reattachMediaStream = reattachStreamToElement;
            getStats = function getPeerConnectionStats(pc, track, successCallback, errorCallback) {
                pc.getStats(track).then(_.bind(handleGetStatsSuccess, this, pc, successCallback), errorCallback);
            };

            webrtcSupported = true;

            break;
        default:
            log('Browser does not appear to be WebRTC-capable', browser);

            break;
        }
    }

    function navigatorGetUserMedia(constraints, successCallback, errorCallback) {
        var onSuccess = _.bind(handleGetUserMediaSuccess, this, constraints, successCallback, errorCallback);

        navigator.getUserMedia(constraints, onSuccess, errorCallback);
    }

    function handleGetUserMediaSuccess(constraints, successCallback, errorCallback, stream) {
        setTimeout(function () {
            var tracks = stream.getTracks();

            for (var i = 0; i < tracks.length; i++) {
                var track = tracks[i];

                track.onended = function (event) {
                    log(event.timeStamp, 'Track', track.id, track.label, 'ended');
                };

                log('Track', track.id, track.label, tracks[i].kind, 'readyState=', tracks[i].readyState);

                if (track.readyState === 'ended') {
                    return handleGetUserMediaUnavailable('User media not available', errorCallback, tracks);
                }
            }

            var requestedTrackCount = (constraints.audio ? 1 : 0) + (constraints.video ? 1 : 0);

            // Edge sometimes only gets a subset of tracks requested
            if (tracks.length !== requestedTrackCount) {
                return handleGetUserMediaUnavailable('Unable to get all requested user media.', errorCallback, tracks);
            }

            successCallback(stream);
        }, 100);
    }

    function handleGetUserMediaUnavailable(message, errorCallback, tracks) {
        try {
            var error = new Error(message);

            error.code = 'unavailable';

            errorCallback(error);
        } finally {
            stopAllTracks(tracks);
        }
    }

    function stopAllTracks(tracks) {
        for (var j = 0; j < tracks.length; j++) {
            tracks[j].stop();
        }
    }

    function navigatorMediaDevicesEnumerateDevicesWrapper(callback) {
        navigator.mediaDevices.enumerateDevices().then(function (devices) {
            var sources = [];

            devices.forEach(function (device) {
                if (device.kind === 'audioinput') {
                    sources.push({
                        kind: 'audio',
                        id: device.deviceId,
                        label: device.label
                    });
                } else if (device.kind === 'videoinput') {
                    sources.push({
                        kind: 'video',
                        id: device.deviceId,
                        label: device.label
                    });
                }
            });

            callback(sources);
        });
    }

    function attachStreamToElement(element, stream) {
        if (typeof element.srcObject !== 'undefined') {
            element.srcObject = stream;
        } else if (typeof element.mozSrcObject !== 'undefined') {
            element.mozSrcObject = stream;
        } else if (typeof element.src !== 'undefined') {
            element.src = URL.createObjectURL(stream);
        } else {
            log('Error attaching stream to element.');
        }

        element.play();

        return element;
    }

    function reattachStreamToElement(to, from) {
        to.src = from.src;

        return to;
    }

    function handleGetStatsSuccess(pc, successCallback, stats) {
        successCallback(normalizePeerConnectionStats(pc, stats));
    }

    function normalizePeerConnectionStats(pc, stats) {
        // TODO (DCY) add vendor specific logic to map all stats to same similar object
        switch (browser.browser) {
        case 'Edge':
            stats.forEach(function (stat) {
                stat.mediaType = getMediaTypeByCodecFromSdp(pc, stat.codecId);
                stat.bytesSent = estimateBytesFromNumberOfPacketsAndMediaType(stat.packetsSent, stat.mediaType);
                stat.bytesReceived = estimateBytesFromNumberOfPacketsAndMediaType(stat.packetsReceived, stat.mediaType);
            });

            break;
        case 'Safari':
            stats.forEach(function (stat) {
                if (_.includes(stat.id.toLowerCase(), 'audio') && _.includes(stat.id.toLowerCase(), 'rtp')) {
                    stat.mediaType = 'audio';
                }

                if (_.includes(stat.id.toLowerCase(), 'video') && _.includes(stat.id.toLowerCase(), 'rtp')) {
                    stat.mediaType = 'video';
                }
            });

            break;
        default:
            break;
        }

        return stats;
    }

    function getMediaTypeByCodecFromSdp(peerConnection, codec) {
        if (!codec) {
            return;
        }

        var mediaType;

        findInSdpSections(peerConnection, function(section) {
            if (_.startsWith(section, 'video') && _.includes(section.toLowerCase(), codec.toLowerCase())) {
                mediaType = 'video';
            }

            if (_.startsWith(section, 'audio') && _.includes(section.toLowerCase(), codec.toLowerCase())) {
                mediaType = 'audio';
            }
        });

        return mediaType;
    }

    function findInSdpSections(peerConnection, callback) {
        var localSections = peerConnection.localDescription.sdp.split('m=');
        var remoteSections = peerConnection.remoteDescription.sdp.split('m=');

        if (localSections.length !== remoteSections.length) {
            return false;
        }

        return _.findIndex(localSections, function(section, index) {
            return callback(section, index, remoteSections);
        });
    }

    function estimateBytesFromNumberOfPacketsAndMediaType(packets, mediaType) {
        var packetsReceivedNum = parseInt(packets) || 0;

        if (mediaType === 'audio') {
            return packetsReceivedNum * 100;
        }

        if (mediaType === 'video') {
            return packetsReceivedNum * 1080;
        }
    }

    shimRTC();

    var adapter = {
        RTCPeerConnection: RTCPeerConnection,
        RTCSessionDescription: RTCSessionDescription,
        RTCIceCandidate: RTCIceCandidate,
        getSources: getSources,
        getUserMedia: getUserMedia,
        getStats: getStats,
        attachMediaStream: attachMediaStream,
        reattachMediaStream: reattachMediaStream,
        webrtcSupported: webrtcSupported
    };

    adapter.exportGlobal = function () {
        window.RTCPeerConnection = adapter.RTCPeerConnection;
        window.RTCSessionDescription = adapter.RTCSessionDescription;
        window.RTCIceCandidate = adapter.RTCIceCandidate;
    };

    return adapter;
});